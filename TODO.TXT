- ResourceAllocator:
	- supprimer les statiques et mettre dans CRaptorInstance ? Les device buffers sont dépendants du contexte ?
	(ctx créé par CRaptorScreenDisplay)
	- supprimer les fonctions SetcurrentInstance: soit allocateurs par contexte, soit par RaptorInstance.

- Test2:
	- mettre au point et utiliser le switch d'instances.

- RaptorFilteredDisplay:
	- voir si normal dans demo que le buffer FSAA ait la même taille que la destination
		(m_fFilterSize = 1 dans RaptorDisplayconfig)

- Supprimer GL_QUADS
	- CGLLayer::glRenderSingleBuffer + glRender
	- GL3DFont::glTTBuildGeometry
	- CAboutVideo::glRender

- CShadedGeometry::removeModel
	- modèle inaccessible en dehors, génère une configuration incorrecte
	(p.ex.: desactive le texturing sur remove Normals)

- RaptorDisplay:
	- renommer glGrab en glBlit en utilisant un CImage.

- ShadowVolume:
	- addObject: recalcul des bbox ? redimensionner un static array pour glvkBindArray
	- Object3DShadow: utiliser un seul shader au lieu de 1 shader par shado wobject ? 
	(==> updateParameters au rendu et non pas offline au calcul des shadows)

- CMipmapBuilder:
	- Reintégrer, pour générer les mipmaps pour Vulkan (vkLoadTexture) ==> source de gluBuild2DMipmaps.

- CTextureFactory:
	- Fusionner vkLoadTexture & glLoadTexture

- CGLFont:
	- corriger font color et back color pour rendre générique
	- sortir les statiques de GLVectorFont et GL2DTextureFont

- Test4:
	- corriger ne marche pas sans relocation
	- Slide: utiliser un CTextureQuad

- COpenGLShaderStage:
	- fusionner vkLoadShader & glLoadProgram (methode virtuelle de CShaderProgram)
	- fusionner vkRender & glRender (methode virtuelle de CShaderProgram)

- CRaptorScreenDisplay:
	- déplacer les resource allocator, ou faire un CRaptorInstance::switchDisplay : 
	sous MFC, le changement de display ne suit pas les ressources ==> plantage de la video dans Test2/About

- CResourceAllocator & co:
	- lock/unlock toujours utile ?
	- à priori non sur les allocate/release car allocation uniquement sur CPU.

- CGeometry:
	- ajouter un cas aux méthodes SetVertices/SetColors/.... si nbV > nb_vertex

- CGeometryPrimitive:
	- Evaluators deprecated => remplacer par geometry shaders.

- CTextureQuad:
	- ajouter une méthode pour faire le render sur une liste de Quads.

- CRaptorDisplay:
	- déplacer les fps et timings dans CRaptorDisplayConfig ( ==> glQueryStatus )

- CRaptorRenderBufferDisplay:
	- appels récurrents à glvkRenderViewPointModel. Pourquoi ? c.f. CRaptorDisplay & m_bApplyViewPointModel.

- CContextManager:
	- factoriser getPresentationSuppotQueueFamily et vk_ctx.pSurface->supportPresentation(physical, numQueue):
		passer le physical device à CVulkanSurface => renvoyer la queue qui supporte WSI et presentation sur la surface.
		=> Passer pExtensions au constructeur.
	- passer en Core profile

- CVulkanMemory:
	- initialiser une bloc mémoire pour l'application (vertex et index buffers bindés sur la même allocation)

- CVulkanShader:
	- Déplacer la gestion du descriptor pool à l'init de ShaderProgram
	- Traiter le cas ou setProgramParameters fournit un set différents (destruction + reallocation)
	- Déplacer la création du Pipeline après InitContext (C3DSCene::PrepareData ?)

- CVulkanCommandBuffer:
	- rendre privée les méthodes et attribut commandbuffer

- CHostMemoryManager:
	- ajouter capacité allocations/release dans un bloc prédéfini (data pool)

- CRaptorRenderBufferDisplay:
	- mettre au point le format CGL_FLOAT_32 (creation des textures attachées)
	- glGenerate : la texture est 'unbindee', or si appelé depuis CTextureObject::glRender ==> ?
	
	
- supprimer des "friend" ?
	p.ex. dans CRaptorDisplay et sous classes ...

- Bumping:
	- comment gérer le filtrage trilinéaire/anisotropique du normal map ?
	- Comment paraméter le shader : EYE_SPACE / OBJECT_SPACE / Ambient occlusion
	- Supprimer CBumppedGeometry => remplacer par le shader.
	- Remplacer / améliorer par displacement map / parallax bump mapping
	
- CRaptorDisplayConfig:
	- faire un sync avec timer (VSync prend 50% CPU!)

- RaptorServer:
	- Rendre thread safe la gestion des clients
		- en particulier la fermeture de connection dans readClients // writeClients
	- Ajouter un mode verbose
	- Tester WSAPoll au lieu de select
	- Passer les sockets en UDP (pour le streaming uniquement ?)

- RaptorCompute
	- corriger Retain/Release sur les mem objects (c.f. test3)
	
- Blur filter
	- il semble que le niveau de blur soit plus bas que ce qu'il devrait être
	(pas assez flou ... ?)
	
- CParticle
	- SMP : si défini, créer des Engine jobs ?
	- OpenCL + GPU computing
	- Positionner les setFactors sur le particle compute depuis l'import (c.f. demo.xml)
	
- CLight
	- glow : volume rendering  ?
	- projection: texture clamping, border fading ...
	- le volume size ne devrait-il pas etre fonction de dmax ?
		c'est le volume de l'objet lumière ! eventuellement, attacher un CObject3D
	- selection de lumière dans 3DSceneObjet: si dans l'angle du cône !
	
- COctree :
	- la subdivision symétrique xyz ne balance pas bien l'arbre:
	on se retrouve avec m_objects > TRESHOLD ( p.ex: 48 ! )
	Voir comment gérer la partition binaire de l'espace selon une direction principale
    
- Ambient occlusion
	- shader FSAO pour ambient occlusion
	- terminer avec tous les types de primitives
	- skipper les faces non visibles (normale transformée a un z negatif)
	- la géométrie "référence" ne peut plus être transformée ? => recharger les textures
	- gestion des coordsPointers/ClientState ... a revoir ? transferer a la geometry ?
	- nombre de geometries occultantes ?
	- remplacer RenderResult par RenderTexture ?

- Noise Generator : 
	- Implémentation full shader

- Bug Microlex:
	dans le cas d'un rule qui est un alternate d'alternate, il n'y a que le premier atome de de la premiere regle qui est selectionne.

- Collisions:
	- Calculer les metaballs optimales
	- algorithme d'intersection : CPU ? GPU ? Pourquoi pas Physx (Havok, accéléré par Intel)

- Optimisations:
	- clipping en SSE / OpenCL
	- glGetFloatv : trop d'appels pour la modelview ( en particulier clipping )
	- Créer des display lists pour le rendu des Light flare ? Il vaudrait mieux faire le lens flare en HDR
	- Pipeline multithread
	- NURBS : implémentation OpenCL ou shaders ou CPU.
	- Rendering no environment: faire un pre rendu en depth pour accélérer le rendu full shaded

- 3DScene :
	- Traiter le cas des lumières multiples dans les shaders et shadows ( ex : bump mapping, shadow volume .)
	- Octrees statiques : comment traiter les mouvements d'objets ? ( remonter les objets au niveau supérieur )
	- Mirror : ne pas activer de lighting et texturing si on est en DEPTH_PASS

- Terminer shadow volumes:
	- Clipping multithread !
	- Shadow volume rendering / Soft Shadow Volume : 
		technique de deferred shading
	- determiner si viewer est inside/outside shadowVolume 
	- depth volume clipping ( scissoring ? )
	- determiner dynamiquement l'extrusion : partiellement fait, reste pb si shadow d'une instance dmax mal calculé ( prendre en compte la transformation )
	- bbox CObject3DShadow
	- CEnvironment : pourquoi un current Light ? (pour shadows)
		supprimer dépendance à currentLight -> utiliser la lumière max du SceneObject (effective lights)
	- CObject3DShadow : seul le premier contour est utilisé (c.f. m_pVisibleContours[0])

- Soft shadow maps:
	- problème de glitch : passer en unit cube ... 
	- Modifier les shadow maps pour travailler avec un TMUSetup plutôt que de taper en dur sur le TMU courant.
	- Corriger shadowmap dans demo
	- Implementer OmniShadowMap
