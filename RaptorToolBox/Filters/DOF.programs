	static const string dof_vp =
	"uniform vec4 offset; \n\
	uniform vec4 vector; \n\
	void main (void) \n\
	{\n\
		gl_TexCoord[0] = gl_MultiTexCoord0; \n\
		gl_TexCoord[1] = gl_MultiTexCoord0 + offset.x*vector; \n\
		gl_TexCoord[2] = gl_MultiTexCoord0 - offset.x*vector; \n\
		gl_TexCoord[3] = gl_MultiTexCoord0 + offset.y*vector; \n\
		gl_TexCoord[4] = gl_MultiTexCoord0 - offset.y*vector; \n\
		gl_TexCoord[5] = gl_MultiTexCoord0 + offset.z*vector; \n\
		gl_TexCoord[6] = gl_MultiTexCoord0 - offset.z*vector; \n\
		gl_Position = ftransform(); \n\
	}\n\
	";

	//	C = A * m * |S2 - S1| / S2
	static const string dof_fp = 
	"uniform sampler2D colorMap;\n\
	uniform sampler2D depthMap;\n\
	uniform vec4 dofParams; \n\
	const float CoC_mag = 2.66; \n\
	\n\
	void main (void) \n\
	{\n\
		vec4 color_base  = texture2D(colorMap,gl_TexCoord[0].xy);\n\
		float depth_base = texture2D(depthMap,gl_TexCoord[0].xy).r;\n\
	\n\
		float CoC_radius = dofParams.z * CoC_mag * abs(depth_base - dofParams.y) / depth_base;\n\
	\n\
		if (CoC_radius > 1.0) \n\
		{\n\
			vec4 color = color_base;\n\
			color += texture2D(colorMap,gl_TexCoord[1].xy);\n\
			color += texture2D(colorMap,gl_TexCoord[2].xy);\n\
			color_base = mix(color_base,color / 3.0,(CoC_radius - 1.0)); \n\
	//		color_base = vec4(1.0, 0.0, 0.0, 1.0); \n\
	\n\
			if (CoC_radius > 2.0) \n\
			{\n\
				vec4 color2 = color; \n\
				color2 += texture2D(colorMap,gl_TexCoord[3].xy);\n\
				color2 += texture2D(colorMap,gl_TexCoord[4].xy);\n\
				color_base = mix(color / 3.0,color2 / 5.0,(CoC_radius - 2.0)); \n\
	//			color_base = vec4(0.0, 1.0, 0.0, 1.0); \n\
	\n\
				if (CoC_radius > 3.0) \n\
				{\n\
					vec4 color3 = color2; \n\
					color3 += texture2D(colorMap,gl_TexCoord[5].xy);\n\
					color3 += texture2D(colorMap,gl_TexCoord[6].xy);\n\
					color_base = mix(color2 / 5.0,color3 / 7.0,(min(CoC_radius,4.0) - 3.0)); \n\
	//				color_base = vec4(0.0, 0.0, 1.0, 1.0); \n\
				} \n\
			}\n\
	\n\
		}\n\
	\n\
		gl_FragColor = color_base; \n\
	}\n\
	";


//	Depth of field color ( eq. fog ):
//	Not applicable as a post processing if RenderBuffer is antialiased.
//	It could be feasible if FSAA is also applied as a (final) postprocess ( quite unlikely )
//
//	float f = smoothstep(dofParams.y,1.0,depth_base); \n\
//	gl_FragColor = mix(dofColor,color_base,exp(-f*f));\n\

